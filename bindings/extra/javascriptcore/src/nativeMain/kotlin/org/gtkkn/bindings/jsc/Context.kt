// This is a generated file. Do not modify.
package org.gtkkn.bindings.jsc

import kotlinx.cinterop.CPointer
import kotlinx.cinterop.StableRef
import kotlinx.cinterop.reinterpret
import org.gtkkn.bindings.gobject.Object
import org.gtkkn.extensions.glib.staticStableRefDestroy
import org.gtkkn.extensions.gobject.GeneratedClassKGType
import org.gtkkn.extensions.gobject.KGTyped
import org.gtkkn.extensions.gobject.TypeCompanion
import org.gtkkn.native.glib.guint
import org.gtkkn.native.gobject.GType
import org.gtkkn.native.jsc.JSCContext
import org.gtkkn.native.jsc.jsc_context_clear_exception
import org.gtkkn.native.jsc.jsc_context_evaluate
import org.gtkkn.native.jsc.jsc_context_evaluate_with_source_uri
import org.gtkkn.native.jsc.jsc_context_get_current
import org.gtkkn.native.jsc.jsc_context_get_exception
import org.gtkkn.native.jsc.jsc_context_get_global_object
import org.gtkkn.native.jsc.jsc_context_get_type
import org.gtkkn.native.jsc.jsc_context_get_value
import org.gtkkn.native.jsc.jsc_context_get_virtual_machine
import org.gtkkn.native.jsc.jsc_context_new
import org.gtkkn.native.jsc.jsc_context_new_with_virtual_machine
import org.gtkkn.native.jsc.jsc_context_pop_exception_handler
import org.gtkkn.native.jsc.jsc_context_push_exception_handler
import org.gtkkn.native.jsc.jsc_context_set_value
import org.gtkkn.native.jsc.jsc_context_throw
import org.gtkkn.native.jsc.jsc_context_throw_exception
import org.gtkkn.native.jsc.jsc_context_throw_with_name
import kotlin.Long
import kotlin.String
import kotlin.Unit

/**
 * JSCContext represents a JavaScript execution context, where all operations
 * take place and where the values will be associated.
 *
 * When a new context is created, a global object is allocated and the built-in JavaScript
 * objects (Object, Function, String, Array) are populated. You can execute JavaScript in
 * the context by using jsc_context_evaluate() or jsc_context_evaluate_with_source_uri().
 * It's also possible to register custom objects in the context with jsc_context_register_class().
 *
 * ## Skipped during bindings generation
 *
 * - parameter `exception`: exception: Out parameter is not supported
 * - parameter `object`: object: Out parameter is not supported
 * - parameter `destroy_notify`: GLib.DestroyNotify
 * - method `throw_printf`: Varargs parameter is not supported
 * - method `throw_with_name_printf`: Varargs parameter is not supported
 */
public class Context(pointer: CPointer<JSCContext>) :
    Object(pointer.reinterpret()),
    KGTyped {
    public val jscContextPointer: CPointer<JSCContext>
        get() = gPointer.reinterpret()

    /**
     * The #JSCVirtualMachine in which the context was created.
     */
    public val virtualMachine: VirtualMachine
        /**
         * Get the #JSCVirtualMachine where @context was created.
         *
         * @return the #JSCVirtualMachine where the #JSCContext was created.
         */
        get() = jsc_context_get_virtual_machine(jscContextPointer)!!.run {
            VirtualMachine(this)
        }

    /**
     * Create a new #JSCContext. The context is created in a new #JSCVirtualMachine.
     * Use jsc_context_new_with_virtual_machine() to create a new #JSCContext in an
     * existing #JSCVirtualMachine.
     *
     * @return the newly created #JSCContext.
     */
    public constructor() : this(jsc_context_new()!!.reinterpret())

    /**
     * Create a new #JSCContext in @virtual_machine.
     *
     * @param vm a #JSCVirtualMachine
     * @return the newly created #JSCContext.
     */
    public constructor(
        vm: VirtualMachine,
    ) : this(jsc_context_new_with_virtual_machine(vm.jscVirtualMachinePointer)!!.reinterpret())

    /**
     * Clear the uncaught exception in @context if any.
     */
    public fun clearException(): Unit = jsc_context_clear_exception(jscContextPointer)

    /**
     * Evaluate @code in @context.
     *
     * @param code a JavaScript script to evaluate
     * @param length length of @code, or -1 if @code is a nul-terminated string
     * @return a #JSCValue representing the last value generated by the script.
     */
    public fun evaluate(code: String, length: Long): Value =
        jsc_context_evaluate(jscContextPointer, code, length)!!.run {
            Value(this)
        }

    /**
     * Evaluate @code in @context using @uri as the source URI. The @line_number is the starting line number
     * in @uri; the value is one-based so the first line is 1. @uri and @line_number will be shown in exceptions and
     * they don't affect the behavior of the script.
     *
     * @param code a JavaScript script to evaluate
     * @param length length of @code, or -1 if @code is a nul-terminated string
     * @param uri the source URI
     * @param lineNumber the starting line number
     * @return a #JSCValue representing the last value generated by the script.
     */
    public fun evaluateWithSourceUri(code: String, length: Long, uri: String, lineNumber: guint): Value =
        jsc_context_evaluate_with_source_uri(jscContextPointer, code, length, uri, lineNumber)!!.run {
            Value(this)
        }

    /**
     * Get the last unhandled exception thrown in @context by API functions calls.
     *
     * @return a #JSCException or null if there isn't any
     *    unhandled exception in the #JSCContext.
     */
    public fun getException(): Exception? = jsc_context_get_exception(jscContextPointer)?.run {
        Exception(this)
    }

    /**
     * Get a #JSCValue referencing the @context global object
     *
     * @return a #JSCValue
     */
    public fun getGlobalObject(): Value = jsc_context_get_global_object(jscContextPointer)!!.run {
        Value(this)
    }

    /**
     * Get a property of @context global object with @name.
     *
     * @param name the value name
     * @return a #JSCValue
     */
    public fun getValue(name: String): Value = jsc_context_get_value(jscContextPointer, name)!!.run {
        Value(this)
    }

    /**
     * Remove the last #JSCExceptionHandler previously pushed to @context with
     * jsc_context_push_exception_handler().
     */
    public fun popExceptionHandler(): Unit = jsc_context_pop_exception_handler(jscContextPointer)

    /**
     * Push an exception handler in @context. Whenever a JavaScript exception happens in
     * the #JSCContext, the given @handler will be called. The default #JSCExceptionHandler
     * simply calls jsc_context_throw_exception() to throw the exception to the #JSCContext.
     * If you don't want to catch the exception, but only get notified about it, call
     * jsc_context_throw_exception() in @handler like the default one does.
     * The last exception handler pushed is the only one used by the #JSCContext, use
     * jsc_context_pop_exception_handler() to remove it and set the previous one. When @handler
     * is removed from the context, @destroy_notify i called with @user_data as parameter.
     *
     * @param handler a #JSCExceptionHandler
     */
    public fun pushExceptionHandler(handler: ExceptionHandler): Unit = jsc_context_push_exception_handler(
        jscContextPointer,
        ExceptionHandlerFunc.reinterpret(),
        StableRef.create(handler).asCPointer(),
        staticStableRefDestroy.reinterpret()
    )

    /**
     * Set a property of @context global object with @name and @value.
     *
     * @param name the value name
     * @param value a #JSCValue
     */
    public fun setValue(name: String, `value`: Value): Unit =
        jsc_context_set_value(jscContextPointer, name, `value`.jscValuePointer)

    /**
     * Throw an exception to @context using the given error message. The created #JSCException
     * can be retrieved with jsc_context_get_exception().
     *
     * @param errorMessage an error message
     */
    public fun `throw`(errorMessage: String): Unit = jsc_context_throw(jscContextPointer, errorMessage)

    /**
     * Throw @exception to @context.
     *
     * @param exception a #JSCException
     */
    public fun throwException(exception: Exception): Unit =
        jsc_context_throw_exception(jscContextPointer, exception.jscExceptionPointer)

    /**
     * Throw an exception to @context using the given error name and message. The created #JSCException
     * can be retrieved with jsc_context_get_exception().
     *
     * @param errorName the error name
     * @param errorMessage an error message
     */
    public fun throwWithName(errorName: String, errorMessage: String): Unit =
        jsc_context_throw_with_name(jscContextPointer, errorName, errorMessage)

    public companion object : TypeCompanion<Context> {
        override val type: GeneratedClassKGType<Context> =
            GeneratedClassKGType(jsc_context_get_type()) { Context(it.reinterpret()) }

        init {
            JavascriptcoreTypeProvider.register()
        }

        /**
         * Get the #JSCContext that is currently executing a function. This should only be
         * called within a function or method callback, otherwise null will be returned.
         *
         * @return the #JSCContext that is currently executing.
         */
        public fun getCurrent(): Context? = jsc_context_get_current()?.run {
            Context(this)
        }

        /**
         * Get the GType of Context
         *
         * @return the GType
         */
        public fun getType(): GType = jsc_context_get_type()
    }
}
